\section{Market Agent (market/agent/)}
\label{Chapters/Implementation/Market-Agent}
The \texttt{Market Agent} plays the role of the Stock Exchange with a central limit order book. The implementation is very clearly split between the messaging subsystem and the part that maintains the order book, executes orders etc., in order to maintain clear separation of concerns and improve ease of unit-testing. 

The messaging subsystem implementation is located in the \\\texttt{eugene.market.esma.impl.behaviours} package and consists of implementations of \texttt{jade.core.behaviours.Behaviour} class (see~\Cref{Chapters/Background/Tools-and-Frameworks}). The \texttt{OrderServer} accepts messages to create new orders, cancel existing orders and handle the logon, i.e. messages from the \texttt{Market Ontology} (\Cref{Chapters/Implementation/Market-Ontology}). Similarly, the \texttt{SimulationOntologyServer} deals with messages from the \texttt{Simulation Ontology} (\Cref{Chapters/Implementation/Simulation-Ontology}). Furthermore, the \texttt{MarketDataServer} deals with sending out trade confirmations to counter parties and market data events (by inspecting the \texttt{MarketDataEngine}, explained below). In order to satisfy requirement \textit{F05}, the \texttt{MarketDataServer} logs the events (using \textit{SLF4J}, see \Cref{Chapters/Background/Tools-and-Frameworks}). The different log files and the format of the logs are explained in~\Cref{Appendix/Logging}.

The second part of the \texttt{Market Agent} is located in the \\ \texttt{eugene.market.esma.impl.execution} package. The \texttt{ExecutionEngine} deals with managing the order book, accepting new orders, cancelling existing orders and matching orders. All the various parts of the \texttt{ExecutionEngine} are refactored to separate classes for ease of testing: \texttt{MatchingEngine} implements the matching algorithm (\Cref{Chapters/Background/Matching-Process}) and \texttt{InsertionValidator} checks whether a market order can be accepted or should be rejected (\Cref{Chapters/Background/Matching-Process}). Every change to the limit order book (inserting a new order, cancelling an existing order and executing an order) triggers an event that is recorded in the \texttt{MarketDataEngine} (\texttt{eugene.market.esma.impl.execution.data} package). The separation of the order characteristics (price, size, type in \texttt{Order}) from the current execution status (\texttt{OrderStatus}) in the \texttt{Order Book} module, greatly simplifies the implementation of the \texttt{MarketDataEngine}: the events can refer to a snapshot of a status of an order and this snapshot can be accessed at any time, as long as a reference to the appropriate \texttt{OrderStatus} object is maintained. 

The points of synchronisation between the messaging subsystem and the execution subsystem are maintained in two classes: the \texttt{Repository} (\texttt{eugene.market.esma.impl} package) and the \texttt{MarketDataEngine}.  The \texttt{Repository} maintains the mapping between current active orders and the owner traders; whenever an order is accepted by the \texttt{OrderServer} it is recorded in the \texttt{Repository}. Similarly, the \texttt{MarketDataServer} retrieves events from the \texttt{MarketDataEngine} and sends them out.

In order to achieve high incoming order rate to handle the required number of \texttt{Trader Agents} (see~\Cref{Chapters/Experiments-and-Results}), the \texttt{OrderServer} and the \texttt{SimulationOntologyServer} operate in a different thread than the \texttt{MarketDataServer}. Therefore, both the \texttt{Repository} and the \texttt{MarketDataEngine} need to be thread-safe (but not the rest of the classes, as they are not shared by different threads). Due to a low number of synchronisation points and clear separation between mutable and immutable state of the order book (\Cref{Chapters/Implementation/Order-Book}), going from single-threaded to multi-threaded design of the \texttt{Market Agent} was relatively straightforward.

In order to satisfy requirement \textit{F06}, various parts of the \texttt{Market Agent} publish performance statistics at runtime, using the \texttt{Metrics} library~\cite{Metrics}. Time to reply to messages and their rate, size of the incoming and outgoing queues, are all published to a \texttt{JMX} bean, that can be read using, e.g. \texttt{JConsole}~\cite{JConsole} that is bundled with \texttt{Java JDK}. Using those statistics we determined that the \texttt{Market Agent} can easily keep up with the required number of \texttt{Trader Agents} (see~\Cref{Chapters/Experiments-and-Results}).
