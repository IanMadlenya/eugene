\section{Testing}
\label{Chapters/Implementation/Testing}
The requirements \textit{N01} and \textit{N02} set out to ensure that the implementation is thoroughly tested. Extensive testing gives confidence in the implementation and allows for safe refactoring of the code, when the design needs to be revisited. Additionally, especially unit-tests, serve as documentation for the code, i.e. in order to explore the usage of a particular class it is very useful to inspect the unit-tests. Moreover, integration tests serve a verification purpose, ensuring that the use cases (see~\Cref{Appendix/Use-Cases}) are correctly implemented.

\subsection{Unit Testing}
In order to fulfil requirement \textit{N01}, the system is extensively unit-tested. Modular architecture and programming to an interface allow for ease of testing (see requirement \textit{N03} and ~\Cref{Chapters/Implementation/Overall-Principles}). Any dependencies can be injected through \textit{mocking}~\citep{Mockito, Powermock}, and therefore tests always test the smallest possible unit of code. 

Tests are written using \textit{TestNG}~\cite{TestNG} testing framework, \textit{hamcrest}~\cite{Hamcrest} for writing powerful and readable assertions and \textit{Mockito}~\cite{Mockito} for mocking. Whenever the code needs to use \texttt{JADE} classes, we use \textit{PowerMock}~\cite{Powermock} to mock them. That is because \texttt{JADE} classes do not usually implement interfaces and often have methods marked \texttt{final}; mocking frameworks like \textit{Mockito} usually use the \textit{Dynamic Proxy API}~\cite{DynamicProxy} and thus cannot deal with methods and classes marked as \texttt{final}. \textit{Powermock} uses a custom classloader and bytecode manipulation in order to enable mocking of such classes. Because it needs to recompile the classes that are mocked, it is much slower; therefore its use is limited only to cases when it is absolutely necessary. Additionally, apart from mocking \texttt{JADE} classes, the code is also tested inside a \texttt{JADE} node, using \texttt{jade-unit}~(See~\Cref{Chapters/Implementation/Jade-Unit}). 

\subsection{Integration Testing (integration/)}
\label{Chapters/Implementation/Integration-Testing}
Integration tests are located in a separate module, as they take more time to run than unit-tests, and therefore do not run after every local change (they do, however, run every time a change is pushed to the main repository, see~\Cref{Chapters/Implementation/Continuous-Integration}). Integration tests fulfil requirement \textit{N02} and serve a verification purpose to ensure that use cases are correctly implemented (see~\Cref{Appendix/Use-Cases}). Integration tests bootstrap the \textit{JADE} node (using \texttt{jade-unit}, see~\Cref{Chapters/Implementation/Jade-Unit}), use the \textit{Simulation Agent} (~\Cref{Chapters/Implementation/Simulation-Agent}) to bootstrap the test agents and the \textit{Market Agent} (~\Cref{Chapters/Implementation/Market-Agent}), and use the \textit{Client API} in order to send messages. The tests then assert whether appropriate responses are sent back. This way all parts of the architecture are tested and the correctness of the overall behaviour is verified.

\subsection{Continuous Integration and Test Coverage}
\label{Chapters/Implementation/Continuous-Integration}
Every push to the main repository triggers a build in \textit{Jenkins}~\cite{Jenkins} (see~\Cref{Appendix/System-Manual}). The code is clean built, all the unit and integration tests are run and instrumented by \textit{Cobertura}~\cite{Cobertura} to calculate test coverage. The requirement \textit{N01} is fulfilled, as the branch test coverage is \texttt{76\%}. Moreover, the true branch test coverage is likely much closer to \texttt{90\%}; that is because \textit{Cobertura} cannot instrument external jars, therefore integration tests (see~\Cref{Chapters/Implementation/Integration-Testing}) do not contribute to the final test coverage. See \Cref{Appendix/Project-Coverage} for Project Coverage report.
